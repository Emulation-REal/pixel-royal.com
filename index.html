<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Black Hole Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #gui { position: absolute; top: 10px; right: 10px; }
        #equation { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; font-size: 16px; background: rgba(0, 0, 0, 0.7); padding: 10px; }
        #hud { position: absolute; bottom: 10px; left: 10px; color: white; font-family: Arial; font-size: 14px; background: rgba(0, 0, 0, 0.5); padding: 5px; }
    </style>
</head>
<body>
    <div id="equation">Schwarzschild Metric: ds² = -(1 - 2GM/c²r)c²dt² + (1 - 2GM/c²r)⁻¹dr² + r²(dθ² + sin²θ dφ²)</div>
    <div id="gui"></div>
    <div id="hud">Hawking Temp: Initializing...</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r169/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.169/examples/jsm/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.169/examples/jsm/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.169/examples/jsm/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.169/examples/jsm/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.169/examples/jsm/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.169/examples/jsm/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/ccapture.js@1.1.0/build/CCapture.all.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x333333);
        document.body.appendChild(renderer.domElement);

        // Orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Post-processing
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.85);
        composer.addPass(bloomPass);

        // Starfield cubemap
        const cubeLoader = new THREE.CubeTextureLoader();
        const bgTexture = cubeLoader.load([
            'https://threejs.org/examples/textures/cube/MilkyWay/px.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/nx.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/py.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/ny.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/pz.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/nz.jpg'
        ], () => console.log('Cubemap loaded'), undefined, (err) => {
            console.error('Cubemap error:', err);
            scene.background = new THREE.Color(0x000022);
        });
        scene.background = bgTexture;

        // Parameters
        let params = {
            rs: 2.0,
            rotationSpeed: 0.005,
            diskGlow: 1.0,
            particleCount: 200,
            lensingStrength: 0.5,
            autoTour: false,
            lowPoly: false,
            exportGIF: function() { startCapture(); }
        };

        // GUI
        const gui = new dat.GUI({ autoPlace: false });
        document.getElementById('gui').appendChild(gui.domElement);
        gui.add(params, 'rs', 1, 5).name('Black Hole Radius').onChange(updateScene);
        gui.add(params, 'rotationSpeed', 0, 0.02).name('Rotation Speed');
        gui.add(params, 'diskGlow', 0, 2).name('Disk Glow');
        gui.add(params, 'particleCount', 50, 500).step(10).name('Hawking Particles').onChange(updateParticles);
        gui.add(params, 'lensingStrength', 0, 1).name('Lensing Strength');
        gui.add(params, 'autoTour').name('Auto Tour Mode');
        gui.add(params, 'lowPoly').name('Low Poly Mode').onChange(updateScene);
        gui.add(params, 'exportGIF').name('Export GIF');

        // Physical constants for Hawking temp (arbitrary units for simplicity)
        const hbar = 1.0545718e-34;
        const c = 3e8;
        const G = 6.67430e-11;
        const kB = 1.380649e-23;
        function calcHawkingTemp(rs) {
            const M = (rs * c * c) / (2 * G); // Mass from Schwarzschild radius
            return (hbar * c * c * c) / (8 * Math.PI * G * M * kB);
        }

        // Event horizon
        const horizonGeometry = new THREE.SphereGeometry(params.rs, 64, 64);
        const horizonMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 } },
            vertexShader: `varying vec3 vNormal; void main() { vNormal = normal; vec3 pos = position + normal * sin(time + position.x * 10.0) * 0.05; gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0); }`,
            fragmentShader: `uniform float time; varying vec3 vNormal; void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); }`
        });
        const horizon = new THREE.Mesh(horizonGeometry, horizonMaterial);
        scene.add(horizon);

        // Gravity grid
        let gridMesh;
        function updateGrid() {
            if (gridMesh) scene.remove(gridMesh);
            const rSteps = params.lowPoly ? 20 : 40;
            const phiSteps = params.lowPoly ? 20 : 40;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const indices = [];
            const rMax = 15;
            const rMin = params.rs + 0.01;
            for (let i = 0; i <= phiSteps; i++) {
                const phi = (i / phiSteps) * 2 * Math.PI;
                for (let j = 0; j <= rSteps; j++) {
                    const r = rMin + (j / rSteps) * (rMax - rMin);
                    const z = 2 * Math.sqrt(params.rs * (r - params.rs)) + Math.sin(phi + Date.now() * 0.001) * 0.2;
                    vertices.push(r * Math.cos(phi), r * Math.sin(phi), z);
                    const t = (r - rMin) / (rMax - rMin);
                    colors.push(1 - t, 0, t);
                }
            }
            for (let i = 0; i < phiSteps; i++) {
                for (let j = 0; j < rSteps; j++) {
                    const a = i * (rSteps + 1) + j;
                    const b = a + 1;
                    const c = (i + 1) * (rSteps + 1) + j;
                    const d = c + 1;
                    indices.push(a, b, b, d, d, c, c, a);
                }
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            const material = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.6 });
            gridMesh = new THREE.LineSegments(geometry, material);
            scene.add(gridMesh);
        }
        updateGrid();

        // Accretion disk with Doppler shift
        const diskGeometry = new THREE.RingGeometry(params.rs * 1.2, params.rs * 3, 64);
        const diskMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 }, glow: { value: params.diskGlow } },
            vertexShader: `varying vec2 vUv; varying vec3 vPos; void main() { vUv = uv; vPos = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `uniform float time; uniform float glow; varying vec2 vUv; varying vec3 vPos; void main() { float intensity = sin(vUv.x * 20.0 + time * 2.0) * 0.5 + 0.5; float doppler = vPos.x > 0.0 ? 0.8 : 0.2; gl_FragColor = vec4(1.0 * doppler, 0.6, 0.1 * (1.0 - doppler), 0.8) * intensity * glow; }`,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const disk = new THREE.Mesh(diskGeometry, diskMaterial);
        disk.rotation.x = Math.PI / 2;
        scene.add(disk);

        // Hawking radiation particles
        let particles;
        function updateParticles() {
            if (particles) scene.remove(particles);
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(params.particleCount * 3);
            for (let i = 0; i < params.particleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = params.rs * (1 + Math.random() * 0.3);
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: params.lowPoly ? 0.1 : 0.05, blending: THREE.AdditiveBlending });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }
        updateParticles();

        // Relativistic jets
        const jetMaterial = new THREE.PointsMaterial({ color: 0x00ffff, size: params.lowPoly ? 0.2 : 0.1, blending: THREE.AdditiveBlending });
        const jetGeometry = new THREE.BufferGeometry();
        const jetPositions = new Float32Array(100 * 3);
        for (let i = 0; i < 100; i++) {
            jetPositions[i * 3] = (Math.random() - 0.5) * 0.2;
            jetPositions[i * 3 + 1] = (Math.random() - 0.5) * 0.2;
            jetPositions[i * 3 + 2] = (i / 99) * 10;
        }
        jetGeometry.setAttribute('position', new THREE.BufferAttribute(jetPositions, 3));
        const northJet = new THREE.Points(jetGeometry, jetMaterial);
        scene.add(northJet);
        const southJet = northJet.clone();
        southJet.rotation.x = Math.PI;
        scene.add(southJet);

        // Photon paths
        function updatePhotons() {
            for (let i = 0; i < 5; i++) {
                const photon = scene.getObjectByName(`photon${i}`);
                if (photon) scene.remove(photon);
            }
            const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
            for (let k = 0; k < 5; k++) {
                const points = [];
                let r = 10, phi = k * (Math.PI * 2 / 5);
                for (let t = 0; t < 100; t++) {
                    const dr = -Math.sqrt(r * (r - params.rs)) * 0.05;
                    phi += 0.1 / (r * r);
                    r += dr;
                    if (r < params.rs) break;
                    points.push(new THREE.Vector3(r * Math.cos(phi), r * Math.sin(phi), Math.sin(t * 0.1) * 0.2));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                line.name = `photon${k}`;
                scene.add(line);
            }
        }
        updatePhotons();

        // Orbiting stars with trails
        const orbiters = [];
        const trails = [];
        for (let i = 0; i < 3; i++) {
            const geo = new THREE.SphereGeometry(0.15, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            const orbiter = new THREE.Mesh(geo, mat);
            orbiter.position.set(5 + i * 2, 0, 0);
            scene.add(orbiter);
            const trailGeo = new THREE.BufferGeometry();
            const trailPos = new Float32Array(100 * 3);
            trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
            const trailMat = new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.3 });
            const trail = new THREE.Line(trailGeo, trailMat);
            scene.add(trail);
            orbiters.push({ mesh: orbiter, radius: 5 + i * 2, speed: 0.01 - i * 0.002, angle: Math.random() * Math.PI * 2 });
            trails.push({ line: trail, positions: [], maxPoints: 100 });
        }

        // 3D equation text
        const fontLoader = new THREE.FontLoader();
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            const textGeometry = new THREE.TextGeometry('ds² = -(1 - 2GM/c²r)c²dt² + ...', {
                font: font,
                size: 0.5,
                height: 0.1
            });
            const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(-5, 5, 5);
            scene.add(textMesh);
        });

        // Gravitational lensing
        const lensingGeometry = new THREE.PlaneGeometry(2, 2);
        const lensingMaterial = new THREE.ShaderMaterial({
            uniforms: { background: { value: bgTexture }, rs: { value: params.rs }, strength: { value: params.lensingStrength } },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
            fragmentShader: `uniform samplerCube background; uniform float rs; uniform float strength; varying vec2 vUv; void main() { vec2 uv = vUv * 2.0 - 1.0; float dist = length(uv); float deflection = (4.0 * rs / (dist + 0.01)) * strength; vec2 bentUv = uv * (1.0 - deflection); vec3 dir = normalize(vec3(bentUv, -1.0)); gl_FragColor = dist < rs / 10.0 ? vec4(0.0, 0.0, 0.0, 1.0) : textureCube(background, dir); }`,
            depthWrite: false
        });
        const lensingQuad = new THREE.Mesh(lensingGeometry, lensingMaterial);
        lensingQuad.position.z = -1;
        scene.add(lensingQuad);

        // Ambient audio
        const listener = new THREE.AudioListener();
        camera.add(listener);
        const sound = new THREE.Audio(listener);
        const audioLoader = new THREE.AudioLoader();
        audioLoader.load('https://threejs.org/examples/sounds/358232_j_spt.flac', (buffer) => {
            sound.setBuffer(buffer);
            sound.setLoop(true);
            sound.setVolume(0.3);
            sound.play();
        }, undefined, (err) => console.error('Audio error:', err));

        // Raycaster for tooltips
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([horizon, disk, ...orbiters.map(o => o.mesh)]);
            document.body.style.cursor = intersects.length > 0 ? 'pointer' : 'default';
        });

        // HUD update
        const hud = document.getElementById('hud');
        function updateHUD() {
            const temp = calcHawkingTemp(params.rs) * 1e20; // Scaled for display
            hud.innerText = `Hawking Temp: ${temp.toFixed(2)} K | Particles: ${params.particleCount} | ${capturer ? 'Recording GIF...' : ''}`;
        }
        updateHUD();

        // GIF capture
        let capturer;
        function startCapture() {
            capturer = new CCapture({ format: 'gif', workersPath: 'https://unpkg.com/ccapture.js@1.1.0/src/', framerate: 30 });
            capturer.start();
            setTimeout(stopCapture, 10000);
            updateHUD();
        }
        function stopCapture() {
            capturer.stop();
            capturer.save();
            capturer = null;
            updateHUD();
        }

        // Update scene
        function updateScene() {
            horizon.scale.set(params.rs / 2, params.rs / 2, params.rs / 2);
            diskGeometry.parameters.innerRadius = params.rs * 1.2;
            diskGeometry.parameters.outerRadius = params.rs * 3;
            diskGeometry.dispose();
            updateGrid();
            updatePhotons();
            updateParticles();
            updateHUD();
        }

        // Camera position
        camera.position.set(12, 12, 12);

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            horizonMaterial.uniforms.time.value = time;
            gridMesh.rotation.y += params.rotationSpeed;
            diskMaterial.uniforms.time.value = time;
            diskMaterial.uniforms.glow.value = params.diskGlow;
            lensingMaterial.uniforms.rs.value = params.rs;
            lensingMaterial.uniforms.strength.value = params.lensingStrength;
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < params.particleCount; i++) {
                positions[i * 3 + 2] += (Math.random() - 0.5) * 0.02;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            orbiters.forEach((orb, i) => {
                orb.angle += orb.speed;
                orb.mesh.position.x = orb.radius * Math.cos(orb.angle);
                orb.mesh.position.y = orb.radius * Math.sin(orb.angle);
                trails[i].positions.push(new THREE.Vector3(orb.mesh.position.x, orb.mesh.position.y, orb.mesh.position.z));
                if (trails[i].positions.length > trails[i].maxPoints) trails[i].positions.shift();
                trails[i].line.geometry.setFromPoints(trails[i].positions);
            });
            if (params.autoTour) {
                camera.position.x = 12 * Math.sin(time * 0.1);
                camera.position.y = 12 * Math.sin(time * 0.05) + 5;
                camera.position.z = 12 * Math.cos(time * 0.1);
                camera.lookAt(0, 0, 0);
            }
            controls.update();
            composer.render();
            if (capturer) capturer.capture(renderer.domElement);
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
