<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Interstellar Black Hole â€” Real-time 3D Simulation (HTML)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  html,body { height:100%; margin:0; background:#000; overflow:hidden; font-family:Inter, system-ui, sans-serif; }
  #ui {
    position: absolute; left: 12px; top: 12px; z-index: 10;
    background: rgba(10,10,12,0.55); color:#e6f0ff; padding:12px; border-radius:10px;
    backdrop-filter: blur(6px); box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    width: 320px;
  }
  #ui h2 { margin:0 0 8px 0; font-size:16px; letter-spacing:0.4px; }
  .row { display:flex; gap:8px; align-items:center; margin:8px 0; }
  .row label { flex:0 0 110px; font-size:13px; color:#cfe8ff; }
  .row input[type=range] { flex:1; }
  .btn { background:#0b57ff; color:white; border:none; padding:8px 10px; border-radius:8px; cursor:pointer; }
  .small { font-size:12px; color:#b9d9ff; margin-top:6px; }
  #footer { position: absolute; left:12px; bottom:12px; color:#9fbff0; font-size:12px; }
</style>
</head>
<body>
<div id="ui">
  <h2>INTERSTELLAR â€” Black Hole Lab ðŸš€</h2>
  <div class="row">
    <label>Black hole mass</label>
    <input id="mass" type="range" min="1" max="1200" value="200" />
  </div>
  <div class="row">
    <label>Lensing strength</label>
    <input id="strength" type="range" min="0" max="6" step="0.01" value="1.2" />
  </div>
  <div class="row">
    <label>Accretion brightness</label>
    <input id="accBright" type="range" min="0" max="4" step="0.01" value="1.2" />
  </div>
  <div class="row">
    <label>Accretion speed</label>
    <input id="accSpeed" type="range" min="0" max="5" step="0.01" value="1.0" />
  </div>
  <div class="row">
    <label>Stars</label>
    <input id="numStars" type="range" min="200" max="2500" step="1" value="900" />
  </div>
  <div class="row">
    <label>Show gravity grid</label>
    <button id="toggleGrid" class="btn">Toggle</button>
  </div>
  <div class="row">
    <label>Spawn planet</label>
    <button id="spawn" class="btn">Add Planet</button>
  </div>
  <div class="small">
    Tip: drag to rotate | scroll to zoom | Double-click to reset. This uses a screen-space approximation of Schwarzschild light deflection: <i>deflection â‰ˆ 4GM/(cÂ² b)</i>.
  </div>
</div>
<div id="footer">Approximate GR lensing â€¢ Real-time Three.js demo â€¢ (open on desktop)</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

// ---------- Scene & basic setup ----------
const canvas = document.createElement('canvas');
document.body.appendChild(canvas);
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputEncoding = THREE.sRGBEncoding;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 10000);
camera.position.set(0, 80, 320);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 20;
controls.maxDistance = 5000;

// ---------- Render target (we render scene to texture, then postprocess lensing) ----------
const rt = new THREE.WebGLRenderTarget(innerWidth * Math.min(window.devicePixelRatio,2), innerHeight * Math.min(window.devicePixelRatio,2), { 
  minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat 
});
rt.texture.encoding = THREE.sRGBEncoding;

// ---------- A big ambient hemisphere light & tiny directional ----------
scene.add(new THREE.AmbientLight(0xffffff, 0.25));
const sunLight = new THREE.DirectionalLight(0xfff7d6, 1.0);
sunLight.position.set(1000, 800, 1200);
scene.add(sunLight);

// ---------- Stars (Point cloud background) ----------
let starPoints = null;
function makeStars(n) {
  if (starPoints) scene.remove(starPoints);
  const geom = new THREE.BufferGeometry();
  const positions = new Float32Array(n * 3);
  const colors = new Float32Array(n * 3);
  for (let i=0;i<n;i++){
    // distribute in a large sphere/shell
    const r = 1500 + Math.random()*4000;
    const theta = Math.acos(2*Math.random()-1);
    const phi = Math.random()*Math.PI*2;
    const x = r * Math.sin(theta) * Math.cos(phi);
    const y = r * Math.sin(theta) * Math.sin(phi);
    const z = r * Math.cos(theta);
    positions[3*i] = x; positions[3*i+1] = y; positions[3*i+2] = z;
    const c = 0.6 + Math.random()*0.4;
    colors[3*i] = c; colors[3*i+1] = c; colors[3*i+2] = c;
  }
  geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
  geom.setAttribute('color', new THREE.BufferAttribute(colors,3));
  const mat = new THREE.PointsMaterial({ size: 2.1, vertexColors:true, sizeAttenuation:true, depthWrite:false });
  starPoints = new THREE.Points(geom, mat);
  scene.add(starPoints);
}
makeStars(900);

// ---------- Planetary systems ----------
const planets = [];
const planetGroup = new THREE.Group();
scene.add(planetGroup);

function spawnPlanetSystem() {
  const central = new THREE.Mesh(
    new THREE.SphereGeometry(2.2 + Math.random()*8, 12, 10),
    new THREE.MeshStandardMaterial({ emissive: 0xffffff, emissiveIntensity: 0.2, color: new THREE.Color().setHSL(Math.random(), 0.5, 0.5) })
  );
  // place randomly far from BH
  const R = 400 + Math.random()*1600;
  const ang = Math.random() * Math.PI*2;
  central.position.set(Math.cos(ang)*R, (Math.random()-0.5)*60, Math.sin(ang)*R);
  planetGroup.add(central);
  
  // add a few planets orbiting this star
  const n = 1 + Math.floor(Math.random()*4);
  const orbiters = [];
  for (let i=0;i<n;i++){
    const rad = 6 + Math.random()*30 + i*18;
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(1.0 + Math.random()*3.5, 12, 10),
      new THREE.MeshStandardMaterial({ roughness:0.8, metalness:0.02, color: new THREE.Color().setHSL(Math.random(),0.6,0.5) })
    );
    sphere.userData = { orbitR: rad, orbitSpeed: 0.001 + Math.random()*0.004, orbitPhase: Math.random()*Math.PI*2, central: central };
    // initial pos relative to central
    sphere.position.copy(central.position).add(new THREE.Vector3(rad, 0, 0));
    planetGroup.add(sphere);
    orbiters.push(sphere);
  }
  planets.push({ star: central, orbiters });
}

// spawn some systems
for (let i=0;i<6;i++) spawnPlanetSystem();

// ---------- Accretion disk (torus-ish ring with shader) ----------
const accGeo = new THREE.TorusGeometry(60, 16, 64, 256);
const accMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  uniforms: {
    uTime: { value: 0 },
    uBright: { value: 1.2 },
    uSpeed: { value: 1.0 },
    cameraPos: { value: camera.position }
  },
  vertexShader: `
    varying vec3 vPos;
    varying vec3 vNormal;
    varying vec3 vWorld;
    void main(){
      vPos = position;
      vNormal = normal;
      vWorld = (modelMatrix * vec4(position,1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vPos;
    varying vec3 vNormal;
    varying vec3 vWorld;
    uniform float uTime;
    uniform float uBright;
    uniform float uSpeed;
    // quick pseudo-Doppler: brighter on approaching side
    void main(){
      // angle around torus
      float ang = atan(vPos.x, vPos.z);
      // radial falloff
      float r = length(vPos.xy);
      // base color (hot inner â†’ yellow, outer â†’ red)
      vec3 hot = vec3(1.0, 0.85, 0.55);
      vec3 cold = vec3(0.95, 0.25, 0.08);
      float t = smoothstep(40.0, 80.0, r);
      vec3 col = mix(hot, cold, t);
      // simulate rotation color shift:
      vec3 veldir = normalize(vec3(-vPos.z, 0.0, vPos.x)); // tangent approx
      // view vector
      vec3 V = normalize(cameraPosition - vWorld);
      float dop = dot(veldir, V); // -1..1
      float dopBoost = 1.0 + dop * 0.8; // exaggerate
      // add animated turbulence
      float noise = 0.35 * sin(10.0*ang + uTime*uSpeed*4.0) * (1.0 - smoothstep(40.0,80.0,r));
      float alpha = smoothstep(63.0, 42.0, r) * 0.9; // keep thin ring
      vec3 finalCol = col * (uBright * dopBoost + noise);
      gl_FragColor = vec4(finalCol, alpha);
    }
  `
});
const accMesh = new THREE.Mesh(accGeo, accMat);
accMesh.rotation.x = Math.PI*0.5;
scene.add(accMesh);

// ---------- Black hole placeholder object (for transforms / debug) ----------
const bh = new THREE.Mesh(new THREE.SphereGeometry(8, 32, 24), new THREE.MeshBasicMaterial({ color: 0x000000 }));
scene.add(bh);
bh.position.set(0,0,0);
bh.userData.Rs = 16.0; // visual Schwarzschild radius (screen-space uses mass control)

/* ---------- Gravity grid (plane with shader lines) ---------- */
const gridGeo = new THREE.PlaneGeometry(1600, 1600, 256, 256);
const gridMat = new THREE.ShaderMaterial({
  uniforms: {
    uMass: { value: 200.0 },
    uCenter: { value: new THREE.Vector3(0,0,0) },
    uOpacity: { value: 0.7 },
    uTime: { value: 0 }
  },
  vertexShader: `
    varying vec3 vPos;
    uniform vec3 uCenter;
    void main(){
      vPos = (modelMatrix * vec4(position, 1.0)).xyz - uCenter;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vPos;
    uniform float uMass;
    uniform float uOpacity;
    uniform float uTime;
    void main(){
      float r = length(vPos.xz) + 0.0001;
      // pseudo gravitational potential (normalized)
      float pot = uMass / r;
      // make contour rings: more contrast near center
      float rings = abs(sin(log(r + 1.0) * 8.0 + uTime * 0.3));
      // use smoothstep to make thin lines
      float lines = smoothstep(0.7,0.71, fract(r*0.03 + sin(uTime*0.05)));
      float intensity = smoothstep(0.0, 1.0, clamp((pot*0.004), 0.0, 1.0));
      vec3 col = vec3(0.18, 0.38, 0.92) * (0.4 + intensity*0.9) * (0.4 + 0.6*rings);
      float a = lines * uOpacity * clamp(1.2 - r*0.002, 0.0, 1.0);
      if (a < 0.001) discard;
      gl_FragColor = vec4(col, a);
    }
  `,
  transparent: true
});
const gridMesh = new THREE.Mesh(gridGeo, gridMat);
gridMesh.rotation.x = -Math.PI*0.5;
gridMesh.position.y = -26;
gridMesh.visible = false;
scene.add(gridMesh);

// ---------- Fullscreen post-process lensing shader ----------
const postScene = new THREE.Scene();
const postCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
const postGeo = new THREE.PlaneGeometry(2,2);
const postMat = new THREE.ShaderMaterial({
  uniforms: {
    tDiffuse: { value: null },
    uBHpos: { value: new THREE.Vector2(0.5, 0.5) }, // screen coords (0..1)
    uMass: { value: 200.0 },
    uStrength: { value: 1.2 },
    uRs: { value: 0.035 }, // normalized Rs in screen coords (approx)
    uTime: { value: 0.0 },
    uPhotonGlow: { value: 1.0 },
    uInnerMask: { value: 0.015 },
  },
  vertexShader: `
    varying vec2 vUv;
    void main(){ vUv = uv; gl_Position = vec4(position,1.0); }
  `,
  fragmentShader: `
    varying vec2 vUv;
    uniform sampler2D tDiffuse;
    uniform vec2 uBHpos;
    uniform float uMass;
    uniform float uStrength;
    uniform float uRs;
    uniform float uTime;
    uniform float uPhotonGlow;
    uniform float uInnerMask;

    // Screen-space lensing approx: deflection ~ 4GM/(c^2 b) (we fold constants into uStrength)
    void main(){
      vec2 uv = vUv;
      vec2 d = uv - uBHpos;
      float r = length(d) + 1e-6;

      // basic radial deflection amount
      float defl = (uMass * uStrength) / (r + 0.0001); // tuneable
      defl *= 0.0005; // scale down for nice visuals

      // we will sample slightly rotated around the BH center for the strong lensing swirl
      float swirl = 0.5 * (1.0 / (r + 0.02));
      vec2 perp = vec2(-d.y, d.x);
      perp = perp / (length(perp)+1e-6);

      vec2 sampleUV = uv + normalize(d) * defl + perp * (defl * 0.2 * swirl);

      // clamp sample coords
      sampleUV = clamp(sampleUV, vec2(0.0), vec2(1.0));

      vec4 sceneCol = texture2D(tDiffuse, sampleUV);

      // create a dark event horizon: black inside scaled Rs
      float horizon = smoothstep(uRs, uRs + 0.006, r);
      // photon ring brightening: add gaussian ring at ~1.75 * Rs (photon sphere approx)
      float ringR = uRs * 1.75;
      float ring = exp(-pow((r - ringR) * 120.0, 2.0)) * uPhotonGlow * (1.0 + 0.9 / (r*50.0 + 0.01));

      // subtle chromatic aberration near ring (simulate gravitational chromatic splitting)
      vec3 col = sceneCol.rgb;
      // add ring glow colour
      col += vec3(1.0, 0.86, 0.55) * ring;

      // attenuate inside horizon
      col *= horizon;

      // vignette-ish increase around BH to emphasize lensing
      float vign = smoothstep(0.5, 0.0, r);
      col = mix(col, vec3(0.0), (1.0 - horizon) * 0.98);

      gl_FragColor = vec4(col, 1.0);
    }
  `,
  transparent: false
});
const postQuad = new THREE.Mesh(postGeo, postMat);
postScene.add(postQuad);

// ---------- UI handling ----------
const massEl = document.getElementById('mass');
const strengthEl = document.getElementById('strength');
const accBrightEl = document.getElementById('accBright');
const accSpeedEl = document.getElementById('accSpeed');
const numStarsEl = document.getElementById('numStars');
const toggleGridBtn = document.getElementById('toggleGrid');
const spawnBtn = document.getElementById('spawn');

massEl.addEventListener('input', () => {
  const val = parseFloat(massEl.value);
  postMat.uniforms.uMass.value = val;
  gridMat.uniforms.uMass.value = val;
  // scale visual Schwarzschild radius roughly with mass (normalized)
  const screenRs = 0.035 + Math.log10(1 + val*0.02) * 0.004;
  postMat.uniforms.uRs.value = screenRs;
});
strengthEl.addEventListener('input', () => { postMat.uniforms.uStrength.value = parseFloat(strengthEl.value); });
accBrightEl.addEventListener('input', () => { accMat.uniforms.uBright.value = parseFloat(accBrightEl.value); });
accSpeedEl.addEventListener('input', () => { accMat.uniforms.uSpeed.value = parseFloat(accSpeedEl.value); });
numStarsEl.addEventListener('input', () => { makeStars(parseInt(numStarsEl.value)); });
toggleGridBtn.addEventListener('click', () => { gridMesh.visible = !gridMesh.visible; });
spawnBtn.addEventListener('click', () => { spawnPlanetSystem(); });

// ---------- Resize ----------
window.addEventListener('resize', onWindowResize);
function onWindowResize(){
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();

  rt.setSize(innerWidth * Math.min(window.devicePixelRatio,2), innerHeight * Math.min(window.devicePixelRatio,2));
}
onWindowResize();

// ---------- Animation loop ----------
let tStart = performance.now();
function animate(){
  requestAnimationFrame(animate);
  const t = (performance.now() - tStart) * 0.001;
  // update accretion shader
  accMat.uniforms.uTime.value = t;
  accMat.uniforms.uSpeed.value = parseFloat(accSpeedEl.value);
  accMat.uniforms.uBright.value = parseFloat(accBrightEl.value);

  gridMat.uniforms.uTime.value = t;

  // orbit planets
  for (let p of planets){
    for (let o of p.orbiters){
      o.userData.orbitPhase += o.userData.orbitSpeed;
      const c = o.userData.central.position;
      const R = o.userData.orbitR;
      o.position.set(c.x + Math.cos(o.userData.orbitPhase) * R, c.y, c.z + Math.sin(o.userData.orbitPhase) * R);
    }
  }

  // Slowly tilt the accretion disk for visual flair
  accMesh.rotation.z += 0.0012;

  // render scene to render target
  renderer.setRenderTarget(rt);
  renderer.render(scene, camera);
  renderer.setRenderTarget(null);

  // compute BH screen pos
  const bhPos = bh.position.clone();
  const proj = bhPos.project(camera);
  const bhScreen = new THREE.Vector2((proj.x * 0.5) + 0.5, (-proj.y * 0.5) + 0.5);
  postMat.uniforms.tDiffuse.value = rt.texture;
  postMat.uniforms.uBHpos.value.copy(bhScreen);
  postMat.uniforms.uTime.value = t;

  // render postscene (full-screen quad)
  renderer.render(postScene, postCam);

  controls.update();
}
animate();

// double-click to reset camera
window.addEventListener('dblclick', () => {
  camera.position.set(0, 80, 320);
  controls.target.set(0,0,0);
  controls.update();
});

// little keyboard shortcuts (over-exaggerated power)
window.addEventListener('keydown', (e) => {
  if (e.key === 'g') gridMesh.visible = !gridMesh.visible;
  if (e.key === 'p') spawnPlanetSystem();
  if (e.key === '1') { postMat.uniforms.uStrength.value *= 1.25; }
  if (e.key === '2') { postMat.uniforms.uStrength.value *= 0.8; }
});

// initial uniform set
massEl.dispatchEvent(new Event('input'));
strengthEl.dispatchEvent(new Event('input'));
accBrightEl.dispatchEvent(new Event('input'));

// ---------- Helpful console output ----------
console.log("Interstellar Black Hole Lab loaded. Shortcuts: g toggle grid, p spawn planet, 1/2 adjust lensing.");
</script>
</body>
</html>
