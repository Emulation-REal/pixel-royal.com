<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Interactive 3D Black Hole System — Emulation Edition</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body { height:100%; margin:0; background:#000; overflow:hidden; font-family: "Segoe UI", Roboto, Arial;}
  #container { width:100%; height:100%; display:block; position:relative; }
  #overlay {
    position:absolute; left:12px; bottom:12px; color:#bfe7ff;
    background: rgba(0,0,0,0.25); padding:10px; border-radius:8px; font-size:13px;
    backdrop-filter: blur(6px); box-shadow: 0 6px 24px rgba(0,0,0,0.6);
  }
  #tips { position:absolute; top:12px; left:12px; color:#fff8; font-size:13px; }
  button { background:#1a6cff; color:white; border:0; padding:6px 10px; border-radius:6px; cursor:pointer; }
  a { color:#9ef; }
  .dg { z-index: 1000 !important; } /* dat.GUI on top */
</style>
</head>
<body>
<div id="container"></div>
<div id="tips">
  Click the view to lock the mouse & enable WASD movement. Use the GUI (top-right) to tweak everything.<br>
  Spawn stars/planets/particle bursts, crank mass up for dramatic lensing, and show off to everyone.
</div>
<div id="overlay">
  <div><strong>Black Hole Sim</strong> — realistic-ish lensing + interactive generation</div>
  <div style="margin-top:6px;">
    <button id="spawnStar">Spawn Star</button>
    <button id="spawnPlanet">Spawn Planet</button>
    <button id="burst">Burst Particles</button>
    <button id="resetScene">Reset Scene</button>
  </div>
</div>

<!-- THREE.js and dat.GUI via CDN -->
<script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.150.0/examples/js/controls/PointerLockControls.js"></script>
<script src="https://unpkg.com/three@0.150.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.150.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.150.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/dat.gui@0.7.9/build/dat.gui.min.js"></script>

<script>
/*
  Interactive 3D Black Hole System
  - Screen-space lensing shader approximates GR deflection (scaled for visuals).
  - Dynamically spawn stars/planets/particles, accretion disk rendering, camera movement.
  - Controls via dat.GUI and on-screen buttons.
*/

// ---------- Scene & Renderer ----------
const container = document.getElementById('container');
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.0012);

// ---------- Camera & Controls ----------
const camera = new THREE.PerspectiveCamera(70, container.clientWidth/container.clientHeight, 0.1, 5000);
camera.position.set(0, 8, 35);

const controls = new THREE.PointerLockControls(camera, renderer.domElement);
let move = { forward:false, backward:false, left:false, right:false };
const velocity = new THREE.Vector3();

document.addEventListener('click', () => {
  if (document.pointerLockElement !== renderer.domElement) {
    controls.lock();
  }
});
controls.addEventListener('lock', () => console.log('Pointer locked — WASD movement active'));
controls.addEventListener('unlock', () => console.log('Pointer unlocked'));

window.addEventListener('keydown', (e) => {
  if (e.code === 'KeyW') move.forward = true;
  if (e.code === 'KeyS') move.backward = true;
  if (e.code === 'KeyA') move.left = true;
  if (e.code === 'KeyD') move.right = true;
});
window.addEventListener('keyup', (e) => {
  if (e.code === 'KeyW') move.forward = false;
  if (e.code === 'KeyS') move.backward = false;
  if (e.code === 'KeyA') move.left = false;
  if (e.code === 'KeyD') move.right = false;
});

// ---------- Black Hole Visual (Sphere + event horizon) ----------
const BH = new THREE.Group();
scene.add(BH);

const bhGeometry = new THREE.SphereGeometry(1, 32, 32);
const bhMaterial = new THREE.MeshBasicMaterial({ color:0x000000 });
const bhMesh = new THREE.Mesh(bhGeometry, bhMaterial);
BH.add(bhMesh);

// horizon glow
const horizonGeo = new THREE.RingGeometry(1.02, 1.6, 64);
const horizonMat = new THREE.MeshBasicMaterial({ color:0xffaa66, side:THREE.DoubleSide, transparent:true, opacity:0.6 });
const horizon = new THREE.Mesh(horizonGeo, horizonMat);
horizon.rotation.x = Math.PI/2;
BH.add(horizon);

// accretion disk (thin torus-ish)
const accGeo = new THREE.RingGeometry(1.8, 8.0, 160, 1);
const accMat = new THREE.MeshBasicMaterial({ color:0xff4500, side:THREE.DoubleSide, transparent:true, opacity:0.8, blending:THREE.AdditiveBlending });
const acc = new THREE.Mesh(accGeo, accMat);
acc.rotation.x = Math.PI/2;
acc.position.y = 0;
BH.add(acc);

// ---------- Starfield (points) ----------
const starGroup = new THREE.Group();
scene.add(starGroup);

function createStarField(count=2000, radius=1500) {
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(count*3);
  const colors = new Float32Array(count*3);
  for (let i=0;i<count;i++){
    const phi = Math.acos(2*Math.random()-1);
    const theta = 2*Math.PI*Math.random();
    const r = 200 + Math.pow(Math.random(), 2) * radius;
    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.sin(phi) * Math.sin(theta);
    const z = r * Math.cos(phi);
    positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;
    const c = 0.8 + Math.random()*0.2;
    colors[i*3]=c; colors[i*3+1]=c; colors[i*3+2]=c;
  }
  geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors,3));
  const mat = new THREE.PointsMaterial({ size:1.2, vertexColors:true, sizeAttenuation:true });
  const pts = new THREE.Points(geometry, mat);
  starGroup.add(pts);
}
createStarField(2500);

// ---------- Objects (planets & stars that orbit) ----------
const orbiting = [];

function spawnOrbiting(isPlanet=true) {
  const radius = 20 + Math.random()*220;
  const angle = Math.random()*Math.PI*2;
  const size = isPlanet ? (0.6 + Math.random()*2.6) : (1.2 + Math.random()*4.0);
  const color = new THREE.Color().setHSL(Math.random(), 0.8, isPlanet ? 0.5 : 0.7);
  const geo = new THREE.SphereGeometry(size, 24, 20);
  const mat = new THREE.MeshStandardMaterial({ color, emissive: color.clone().multiplyScalar(0.05), roughness:0.6, metalness:0.05 });
  const m = new THREE.Mesh(geo, mat);
  m.position.set(Math.cos(angle)*radius, (Math.random()-0.5)*6, Math.sin(angle)*radius);
  scene.add(m);

  // give orbital params
  const orb = {
    mesh: m,
    radius,
    angle,
    speed: (0.2 + Math.random()*0.9) * (isPlanet ? 0.6 : 0.25) / Math.sqrt(radius) ,
    tilt: (Math.random()-0.5)*0.4,
    isPlanet
  };
  orbiting.push(orb);
}

// spawn a few initial orbiters
for (let i=0;i<6;i++) spawnOrbiting(Math.random()>0.5);

// ---------- Particles system for bursts ----------
const particleGroup = new THREE.Group();
scene.add(particleGroup);

function burstParticles(count=200) {
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  const vel = [];
  for (let i=0;i<count;i++){
    pos[i*3]=0; pos[i*3+1]=0; pos[i*3+2]=0;
    const dir = new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).normalize();
    const speed = 5 + Math.random()*40;
    vel.push(dir.multiplyScalar(speed));
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  const mat = new THREE.PointsMaterial({ size:0.9, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending });
  const points = new THREE.Points(geo, mat);
  points.userData.vel = vel;
  particleGroup.add(points);
  setTimeout(()=>{ particleGroup.remove(points); }, 7000);
}

// ---------- Lights ----------
const hemi = new THREE.HemisphereLight(0x99ccff, 0x222244, 0.6);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(-10,20,15);
scene.add(dir);

// ---------- Postprocessing: Screen-space lensing shader ----------
const composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);

// Lens shader: samples the rendered texture and displaces UVs based on distance from BH center.
// Uses a visually-scaled deflection formula approximating 4GM/(c^2 b). We provide GUI sliders to scale it.
const LENS_SHADER = {
  uniforms: {
    "tDiffuse": { value: null },
    "resolution": { value: new THREE.Vector2(container.clientWidth, container.clientHeight) },
    "bhPos": { value: new THREE.Vector2(0.5, 0.5) }, // in screen UVs
    "strength": { value: 0.6 }, // visual deflection strength
    "eventHorizon": { value: 0.05 },
    "spin": { value: 0.0 },
    "time": { value: 0 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform vec2 resolution;
    uniform vec2 bhPos;
    uniform float strength;
    uniform float eventHorizon;
    uniform float spin;
    uniform float time;
    varying vec2 vUv;

    // easing for samples
    float ease(float x){ return smoothstep(0.0, 1.0, x); }

    void main(){
      vec2 uv = vUv;
      vec2 toBH = uv - bhPos;
      float dist = length(toBH);
      // normalized impact parameter (b)
      float b = dist;

      // approximate deflection angle (scaled for visuals).
      // theoretical: alpha = 4GM/(c^2 b). We'll fold constants into strength.
      float alpha = strength / max(b, 0.0001);

      // add spin-like skew (Kerr-ish visual)
      float spinAngle = spin * 0.5 * sin(time*0.3 + dist*40.0);

      // displacement direction is perpendicular to the radial vector (bending towards BH)
      vec2 bendDir = normalize(toBH);
      // perpendicular
      vec2 perp = vec2(-bendDir.y, bendDir.x);

      // radial inward component (pulling light inward)
      vec2 inward = -bendDir * alpha * 0.35;
      // tangential asymmetric spin / frame-dragging-ish effect
      vec2 tangential = perp * alpha * 0.8 * spin * 0.6;

      // combine and scale by a falloff with distance (strong near BH)
      float falloff = exp(-dist*6.0) * ease(1.0 - smoothstep(eventHorizon, 0.6, dist));
      vec2 displacement = (inward + tangential) * falloff;

      // sample from displaced uv
      vec2 sampleUV = uv + displacement;

      // if inside event horizon, darken strongly and smear
      float inside = smoothstep(eventHorizon*1.1, eventHorizon, dist);
      vec4 color = texture2D(tDiffuse, sampleUV);

      // smear / glow near horizon
      float glow = exp(-pow(dist/eventHorizon, 2.0)*6.0);
      vec4 glowColor = vec4(1.0, 0.55, 0.25, 1.0) * glow * 0.9;

      // chromatic aberration effect for drama
      float ca = 0.008 * falloff;
      vec3 col;
      col.r = texture2D(tDiffuse, sampleUV + vec2(ca,0.0)).r;
      col.g = texture2D(tDiffuse, sampleUV).g;
      col.b = texture2D(tDiffuse, sampleUV - vec2(ca,0.0)).b;

      // mix in glow and horizon darkness
      vec3 final = mix(col, vec3(0.0), inside*0.98) + glowColor.rgb * (1.0 - inside);

      gl_FragColor = vec4(final, 1.0);
    }
  `
};

const lensPass = new THREE.ShaderPass(LENS_SHADER);
lensPass.renderToScreen = true;
composer.addPass(lensPass);

// ---------- GUI controls ----------
const params = {
  mass: 1.0,             // visual mass scale (affects lens strength)
  lensStrength: 0.6,    // multiplier for shader
  eventHorizon: 0.05,   // normalized radius in UV
  accretionBrightness: 0.8,
  spin: 0.2,
  particleBurstSize: 250,
  starCount: 2500,
  reset: () => { resetScene(); },
};

const gui = new dat.GUI();
gui.add(params, 'mass', 0.02, 3.5, 0.01).name('Mass (visual)').onChange(v => { params.lensStrength = v * 0.6; updateGUIValues(); });
gui.add(params, 'lensStrength', 0.0, 3.0, 0.01).name('Lensing Strength').onChange(updateGUIValues);
gui.add(params, 'eventHorizon', 0.01, 0.12, 0.001).name('Event Horizon').onChange(updateGUIValues);
gui.add(params, 'accretionBrightness', 0.0, 2.5, 0.01).name('Accretion Bright').onChange(updateAccretion);
gui.add(params, 'spin', 0.0, 1.2, 0.01).name('Spin (visual)').onChange(updateGUIValues);
gui.add(params, 'particleBurstSize', 50, 2000, 1).name('Burst Size');
gui.add(params, 'starCount', 500, 8000, 100).name('Star Count').onChange(v => regenerateStars(v));
gui.add(params, 'reset').name('Reset Scene');

function updateGUIValues() {
  lensPass.uniforms['strength'].value = params.lensStrength;
  lensPass.uniforms['eventHorizon'].value = params.eventHorizon;
  lensPass.uniforms['spin'].value = params.spin;
  horizon.scale.set(params.eventHorizon*30, params.eventHorizon*30, 1);
}

function updateAccretion() {
  acc.material.opacity = Math.min(1.6, Math.max(0.05, params.accretionBrightness));
  acc.scale.set(1 + params.accretionBrightness*0.6, 1 + params.accretionBrightness*0.6, 1);
}

function regenerateStars(n) {
  // remove and recreate
  starGroup.clear();
  createStarField(n, 1300);
}

// ---------- UI Buttons ----------
document.getElementById('spawnStar').addEventListener('click', ()=>spawnOrbiting(false));
document.getElementById('spawnPlanet').addEventListener('click', ()=>spawnOrbiting(true));
document.getElementById('burst').addEventListener('click', ()=>burstParticles(params.particleBurstSize));
document.getElementById('resetScene').addEventListener('click', ()=>resetScene());

function resetScene() {
  // remove orbiters
  orbiting.forEach(o => scene.remove(o.mesh));
  orbiting.length = 0;
  // remove particles
  particleGroup.clear();
  // default objects
  for (let i=0;i<6;i++) spawnOrbiting(Math.random()>0.5);
  camera.position.set(0,8,35); camera.lookAt(0,0,0);
  params.mass = 1.0; params.lensStrength=0.6; params.eventHorizon=0.05; params.accretionBrightness=0.8; params.spin=0.2;
  updateGUIValues(); updateAccretion();
}

// ---------- Resize ----------
window.addEventListener('resize', onWindowResize);
function onWindowResize(){
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
  composer.setSize(container.clientWidth, container.clientHeight);
  lensPass.uniforms['resolution'].value.set(container.clientWidth, container.clientHeight);
}

// ---------- Animation loop ----------
const clock = new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(0.06, clock.getDelta());
  const t = clock.elapsedTime;

  // Camera movement
  const speed = 40.0;
  velocity.set(0,0,0);
  if (move.forward) velocity.z -= 1;
  if (move.backward) velocity.z += 1;
  if (move.left) velocity.x -= 1;
  if (move.right) velocity.x += 1;
  // normalize & move in camera local space
  if (velocity.lengthSq()>0) {
    velocity.normalize().multiplyScalar(speed * dt);
    controls.moveRight(velocity.x);
    controls.getObject().position.y += velocity.y;
    controls.moveForward(velocity.z);
  }

  // orbiting objects update (simple circular orbits)
  for (let o of orbiting) {
    o.angle += o.speed * dt;
    const x = Math.cos(o.angle) * o.radius;
    const z = Math.sin(o.angle) * o.radius;
    o.mesh.position.set(x, Math.sin(t*0.1 + o.angle*0.3)*o.tilt*10, z);
    // subtle rotation
    o.mesh.rotation.y += 0.005 + (o.isPlanet?0.02:0.005);
  }

  // particle update
  particleGroup.children.forEach(points => {
    const posAttr = points.geometry.attributes.position;
    for (let i=0;i<posAttr.count;i++){
      posAttr.array[i*3] += points.userData.vel[i].x * dt;
      posAttr.array[i*3+1] += points.userData.vel[i].y * dt;
      posAttr.array[i*3+2] += points.userData.vel[i].z * dt;
      // simple BH gravity pull for particles
      const px = posAttr.array[i*3], py=posAttr.array[i*3+1], pz=posAttr.array[i*3+2];
      const r2 = px*px + py*py + pz*pz + 0.0001;
      const g = Math.min(400.0 / r2, 60.0);
      const dir = new THREE.Vector3(-px, -py, -pz).multiplyScalar(g*dt);
      points.userData.vel[i].add(dir);
    }
    posAttr.needsUpdate = true;
  });

  // accretion rotation
  acc.rotation.z += params.spin * 0.01 + 0.002;

  // update lens shader with BH screen position
  // project BH (0,0,0) to screen UV
  const bhWorldPos = new THREE.Vector3();
  BH.getWorldPosition(bhWorldPos);
  const ndc = bhWorldPos.clone().project(camera);
  const uvx = 0.5 + ndc.x*0.5;
  const uvy = 0.5 + ndc.y*0.5;
  lensPass.uniforms['bhPos'].value.set(uvx, uvy);
  lensPass.uniforms['time'].value = t;

  // dynamic parameters
  lensPass.uniforms['strength'].value = params.lensStrength;
  lensPass.uniforms['eventHorizon'].value = params.eventHorizon;
  lensPass.uniforms['spin'].value = params.spin;

  // render
  composer.render(dt);
}
updateGUIValues(); updateAccretion();
animate();

// ---------- Initial camera light and small helpers ----------
const ambient = new THREE.AmbientLight(0x222222, 0.6);
scene.add(ambient);

// ---------- Helpful keyboard UI hints ----------
window.addEventListener('keydown', (e) => {
  if (e.key === 'h') {
    alert('Controls:\n- Click to lock pointer (mouse look)\n- WASD to move\n- Use GUI to tweak mass, lensing, event horizon, spin\n- Spawn stars/planets and particle bursts with buttons\n- Press Reset Scene to return to defaults');
  }
});

// ---------- tiny performance fallback ----------
let lastFrame = performance.now();
setInterval(()=> {
  const now = performance.now();
  const fps = 1000 / Math.max(1, (now - lastFrame));
  lastFrame = now;
  if (fps < 20) {
    renderer.setPixelRatio(0.75); // degrade
  } else {
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  }
}, 2000);

</script>
</body>
</html>
