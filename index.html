<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scrolling Zombie Royale Inspired Game</title>
<style>
  /* Reset */
  * {
    box-sizing: border-box;
    user-select: none;
  }
  body {
    margin: 0;
    background: #121212;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #eee;
    overflow: hidden;
  }
  #gameContainer {
    position: relative;
    width: 800px;
    height: 600px;
    margin: 20px auto;
    border: 2px solid #33ff99;
    background: #222;
    overflow: hidden;
    box-shadow: 0 0 15px #33ff99;
  }
  canvas {
    display: block;
    background: #111;
  }

  /* Inventory Panel */
  #inventory {
    position: absolute;
    right: 10px;
    bottom: 10px;
    width: 280px;
    height: 140px;
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid #33ff99;
    border-radius: 10px;
    display: flex;
    flex-wrap: wrap;
    padding: 10px;
    gap: 8px;
    box-shadow: 0 0 8px #33ff99;
  }
  .inv-slot {
    width: 60px;
    height: 60px;
    background: #222;
    border: 2px solid #444;
    border-radius: 6px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: border-color 0.2s;
    position: relative;
  }
  .inv-slot:hover {
    border-color: #33ff99;
  }
  .inv-slot img {
    max-width: 48px;
    max-height: 48px;
  }
  .inv-count {
    position: absolute;
    bottom: 4px;
    right: 6px;
    font-size: 12px;
    color: #33ff99;
    font-weight: bold;
    text-shadow: 0 0 4px black;
  }

  /* Health Bar */
  #healthBarContainer {
    position: absolute;
    left: 10px;
    top: 10px;
    width: 250px;
    height: 28px;
    background: #222;
    border: 2px solid #ff4444;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 0 10px #ff4444;
  }
  #healthBar {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, #ff5555, #cc0000);
    transition: width 0.3s ease-out;
  }
  #healthText {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    text-align: center;
    line-height: 28px;
    font-weight: bold;
    color: #eee;
    text-shadow: 0 0 5px black;
    pointer-events: none;
  }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <div id="healthBarContainer">
    <div id="healthBar"></div>
    <div id="healthText">100 / 100 HP</div>
  </div>

  <div id="inventory">
    <!-- Inventory slots dynamically generated -->
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const INV_SLOTS = 12;

  // Game state
  const game = {
    mapWidth: 2000,
    mapHeight: 2000,
    player: {
      x: 1000,
      y: 1000,
      size: 30,
      speed: 4,
      color: '#33ff99',
      health: 100,
      maxHealth: 100,
      inventory: new Array(INV_SLOTS).fill(null),
    },
    keys: {},
    itemsOnMap: [],
    viewport: {
      x: 0,
      y: 0,
      width: canvas.width,
      height: canvas.height,
    },
  };

  // Items definitions
  const itemTypes = {
    medkit: {
      name: 'Medkit',
      color: '#ff4444',
      size: 20,
      imgSrc: null,
      healAmount: 25,
    },
    ammo: {
      name: 'Ammo',
      color: '#4444ff',
      size: 20,
      imgSrc: null,
      count: 10,
    },
    shield: {
      name: 'Shield',
      color: '#33ccff',
      size: 20,
      imgSrc: null,
      shieldPoints: 50,
    },
  };

  // Create random items scattered on map
  function createRandomItems() {
    for (let i = 0; i < 30; i++) {
      const typeKeys = Object.keys(itemTypes);
      const randomType = typeKeys[Math.floor(Math.random() * typeKeys.length)];
      game.itemsOnMap.push({
        type: randomType,
        x: Math.random() * (game.mapWidth - 40) + 20,
        y: Math.random() * (game.mapHeight - 40) + 20,
      });
    }
  }
  createRandomItems();

  // Inventory UI
  const inventoryEl = document.getElementById('inventory');

  function createInventorySlots() {
    inventoryEl.innerHTML = '';
    for (let i = 0; i < INV_SLOTS; i++) {
      const slot = document.createElement('div');
      slot.className = 'inv-slot';
      slot.dataset.slot = i;
      inventoryEl.appendChild(slot);
    }
  }
  createInventorySlots();

  function updateInventoryUI() {
    const slots = inventoryEl.querySelectorAll('.inv-slot');
    slots.forEach((slotEl, i) => {
      const item = game.player.inventory[i];
      slotEl.innerHTML = '';
      if (item) {
        // Draw a colored circle with item name or icon placeholder
        const circle = document.createElement('div');
        circle.style.width = '40px';
        circle.style.height = '40px';
        circle.style.borderRadius = '50%';
        circle.style.background = itemTypes[item.type].color;
        circle.style.display = 'flex';
        circle.style.justifyContent = 'center';
        circle.style.alignItems = 'center';
        circle.style.color = '#000';
        circle.style.fontWeight = 'bold';
        circle.textContent = itemTypes[item.type].name[0];
        slotEl.appendChild(circle);

        if (item.count && item.count > 1) {
          const countEl = document.createElement('div');
          countEl.className = 'inv-count';
          countEl.textContent = item.count;
          slotEl.appendChild(countEl);
        }
      }
    });
  }

  updateInventoryUI();

  // Health UI
  const healthBar = document.getElementById('healthBar');
  const healthText = document.getElementById('healthText');

  function updateHealthUI() {
    const pct = game.player.health / game.player.maxHealth;
    healthBar.style.width = (pct * 100) + '%';
    healthText.textContent = `${game.player.health} / ${game.player.maxHealth} HP`;
  }
  updateHealthUI();

  // Controls
  window.addEventListener('keydown', e => {
    game.keys[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', e => {
    game.keys[e.key.toLowerCase()] = false;
  });

  // Helper: clamp value
  function clamp(num, min, max) {
    return Math.min(Math.max(num, min), max);
  }

  // Pick up item if touching
  function tryPickup() {
    for (let i = 0; i < game.itemsOnMap.length; i++) {
      const item = game.itemsOnMap[i];
      const dist = Math.hypot(game.player.x - item.x, game.player.y - item.y);
      if (dist < game.player.size + 15) {
        // Try to add item to inventory
        addItemToInventory(item.type);
        game.itemsOnMap.splice(i, 1);
        i--;
      }
    }
  }

  // Add item to inventory (stack if possible)
  function addItemToInventory(type) {
    // Check if item already exists (stack)
    for (let i = 0; i < game.player.inventory.length; i++) {
      const slot = game.player.inventory[i];
      if (slot && slot.type === type) {
        if (slot.count) {
          slot.count++;
        } else {
          slot.count = 2;
        }
        updateInventoryUI();
        return;
      }
    }
    // Add new item to first empty slot
    for (let i = 0; i < game.player.inventory.length; i++) {
      if (!game.player.inventory[i]) {
        game.player.inventory[i] = { type, count: 1 };
        updateInventoryUI();
        return;
      }
    }
    // Inventory full - do nothing or could show message
  }

  // Use item from inventory slot
  function useItem(slotIndex) {
    const item = game.player.inventory[slotIndex];
    if (!item) return;

    switch(item.type) {
      case 'medkit':
        game.player.health = clamp(game.player.health + 25, 0, game.player.maxHealth);
        item.count--;
        if (item.count <= 0) game.player.inventory[slotIndex] = null;
        break;
      case 'ammo':
        // For demo, just remove one ammo on use
        item.count--;
        if (item.count <= 0) game.player.inventory[slotIndex] = null;
        break;
      case 'shield':
        // Could add shield points
        item.count--;
        if (item.count <= 0) game.player.inventory[slotIndex] = null;
        break;
    }
    updateInventoryUI();
    updateHealthUI();
  }

  // Inventory slot click
  inventoryEl.addEventListener('click', (e) => {
    const slotEl = e.target.closest('.inv-slot');
    if (!slotEl) return;
    const idx = parseInt(slotEl.dataset.slot);
    useItem(idx);
  });

  // Main game loop
  function gameLoop() {
    // Move player based on keys
    let dx = 0, dy = 0;
    if (game.keys['arrowup'] || game.keys['w']) dy -= game.player.speed;
    if (game.keys['arrowdown'] || game.keys['s']) dy += game.player.speed;
    if (game.keys['arrowleft'] || game.keys['a']) dx -= game.player.speed;
    if (game.keys['arrowright'] || game.keys['d']) dx += game.player.speed;

    // Normalize diagonal speed
    if (dx !== 0 && dy !== 0) {
      dx *= 0.7071;
      dy *= 0.7071;
    }

    game.player.x = clamp(game.player.x + dx, 0, game.mapWidth);
    game.player.y = clamp(game.player.y + dy, 0, game.mapHeight);

    // Update viewport so player is centered but clamps at map edges
    game.viewport.x = clamp(game.player.x - game.viewport.width / 2, 0, game.mapWidth - game.viewport.width);
    game.viewport.y = clamp(game.player.y - game.viewport.height / 2, 0, game.mapHeight - game.viewport.height);

    // Try picking up items near player
    tryPickup();

    // Draw everything
    draw();

    requestAnimationFrame(gameLoop);
  }

  // Draw function
  function draw() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw background grid (like zombie royale style minimal grid)
    const gridSize = 50;
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    for(let x = - (game.viewport.x % gridSize); x < canvas.width; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    for(let y = - (game.viewport.y % gridSize); y < canvas.height; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }

    // Draw items on map
    game.itemsOnMap.forEach(item => {
      const screenX = item.x - game.viewport.x;
      const screenY = item.y - game.viewport.y;
      const typeInfo = itemTypes[item.type];
      ctx.fillStyle = typeInfo.color;
      ctx.beginPath();
      ctx.arc(screenX, screenY, typeInfo.size / 2, 0, Math.PI * 2);
      ctx.fill();

      // Draw icon letter for item
      ctx.fillStyle = '#000';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(typeInfo.name[0], screenX, screenY);
    });

    // Draw player
    const px = game.player.x - game.viewport.x;
    const py = game.player.y - game.viewport.y;

    ctx.fillStyle = game.player.color;
    ctx.beginPath();
    ctx.arc(px, py, game.player.size / 2, 0, Math.PI * 2);
    ctx.fill();

    // Player eyes (direction indication)
    const eyeOffset = 7;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(px - eyeOffset/2, py - eyeOffset/2, 5, 0, Math.PI * 2);
    ctx.arc(px + eyeOffset/2, py - eyeOffset/2, 5, 0, Math.PI * 2);
    ctx.fill();

    // Draw player outline glow
    ctx.strokeStyle = '#33ff99';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(px, py, game.player.size / 2 + 3, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Start game loop
  gameLoop();

})();
</script>

</body>
</html>
